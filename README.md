# Golang内网端口映射实现

Rust实现参考：https://github.com/pysrc/breaknet

bilibili地址：https://www.bilibili.com/video/BV1TD4y1d7s4/

![原理示例](原理示例.png)

# 配置说明

**json配置文件中含"-"的为非必配字段**


```json
{
    "server": {
        "key": "helloworld", // 客户端与服务端必须对应，且用于数据加密
        "port": 8808, // 服务端控制端口，供负责二次转发的 client 访问
        "-limit-port": [ // 留给客户端选择的端口范围 (注意，这是一个范围，此数组有且只能有两个端口，一个开始，一个结束)
            9100,  // 范围内对应的端口需要打开（在阿里或腾讯等平台上解开防火墙）
            9110   // 范围内对应的端口需要打开（在阿里或腾讯等平台上解开防火墙）
        ]
    },
    "client": {
        "key": "helloworld", // 客户端（负责二次转发的端）与服务端必须对应，且用于数据加密
        "server": "99.88.66.55:8808", // 填服务端对外的IP与端口，如果本地测试则填 127.0.0.1
        "map": [ // 内网映射到服务端的规则
            {
                "inner": "127.0.0.1:6375", // 内网地址, 某个端口，比如 6375 上的服务
                "outer": 9100 // 映射到服务端指定端口范围内的端口
            },
            {
                "inner": "127.0.0.1:6376", // 内网地址, 某个端口，比如 6376 上的服务
                "outer": 9101 // 映射到服务端指定端口范围内的端口
            },
            {
                "inner": "127.0.0.1:6377", // 内网地址, 某个端口，比如 6377 上的服务
                "outer": 9102 // 映射到服务端指定端口范围内的端口
            },
            {
                "inner": "127.0.0.1:8888",
                "outer": 9103 // 映射到服务端指定端口范围内的端口
            }
        ]
    }
}

```
